<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Fast Reflection | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Fast Reflection | .NEXT ">
    <meta name="generator" content="docfx 2.48.0.0">
    
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="fast-reflection">Fast Reflection</h1>

<p>Invocation of reflected members in .NET is slow. This happens because late-binding <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodbase.invoke">invocation</a> should provide type check of arguments for each call. DotNext Reflection library provides a way to invoke reflected members in strongly typed manner. It means that invocation parameters are typed and type safety is guaranteed by compiler. Moreover, this feature allows to invoke members with the same performance as they called without reflection. The reflected member can be converted into appropriate delegate instance for caching and further invocation. The binding process still performed dynamically and based on .NET reflection.</p>
<p><a href="../../api/DotNext.Reflection.Reflector.html">Reflector</a> class provides methods for reflecting class members. The type of delegate instance which represents reflected member describes the signature of the method or constructor. But what the developer should do if one of constructor or method parameteters has a type that is not visible from the calling code (e.g. type has <strong>internal</strong> visibility modifier and located in third-party library)? This issue is covered by Reflection library with help of the following special delegate types:</p>
<ul>
<li><a href="../../api/DotNext.Function-2.html">Function&lt;A, R&gt;</a> for static methods with return type</li>
<li><a href="../../api/DotNext.Function-3.html">Function&lt;T, A, R&gt;</a> for instance methods with return type</li>
<li><a href="../../api/DotNext.Procedure-1.html">Procedure&lt;A&gt;</a> for static methods without return type</li>
<li><a href="../../api/DotNext.Procedure-2.html">Procedure&lt;T, A&gt;</a> for instance methods without return type</li>
</ul>
<p>These delegates can describe signature of arbitrary methods or constructors with a little performance cost: all arguments will passed through stack. As a result, they can be used if developer don't want to introduce a new delegate type for some untypical signatures (with <strong>ref</strong> or <strong>out</strong> parameters).</p>
<h1 id="constructor">Constructor</h1>
<p>Constructor can be reflected as delegate instance.</p>
<pre><code class="lang-csharp">using System.IO;
using DotNext.Reflection;

Func&lt;byte[], bool, MemoryStream&gt; ctor = typeof(MemoryStream).GetConstructor(new[] { typeof(byte[]), typeof(bool) }).Unreflect&lt;Func&lt;byte[], bool, MemoryStream&gt;&gt;();
using(var stream = ctor(new byte[] { 1, 10, 5 }, false))
{

}
</code></pre>
<p>The same behavior can be achieved using <em>Function</em> special delegate:</p>
<pre><code class="lang-csharp">using System.IO;
using DotNext.Reflection;

Function&lt;(byte[] buffer, bool writable), MemoryStream&gt; ctor = typeof(MemoryStream).GetConstructor(new[] { typeof(byte[]), typeof(bool) }).Unreflect&lt;Function&lt;(byte[], bool), MemoryStream&gt;&gt;();

var args = ctor.ArgList();
args.buffer = new byte[] { 1, 10, 5 };
args.writable = false;
using(var stream = ctor(args))
{

}
</code></pre>
<p>Moreover, it is possible to use custom delegate type for reflection:</p>
<pre><code class="lang-csharp">using DotNext.Reflection;
using System.IO;

internal delegate MemoryStream MemoryStreamConstructor(byte[] buffer, bool writable);

MemoryStreamConstructor ctor = typeof(MemoryStream).GetConstructor(new[] { typeof(byte[]), typeof(bool) }).Unreflect&lt;MemoryStreamConstructor&gt;();
using(var stream = ctor(new byte[] { 1, 10, 5 }, false))
{

}
</code></pre>
<h1 id="method">Method</h1>
<p>Static or instance method can be reflected as delegate instance. In case of instance method, first argument of the delegate should accept <strong>this</strong> argument:</p>
<ul>
<li><em>T</em> for reference type</li>
<li><em>ref T</em> for value type</li>
</ul>
<pre><code class="lang-csharp">using System.Numerics;
using DotNext.Reflection;

internal delegate byte[] ToByteArray(ref BigInteger @this);

var toByteArray = typeof(BigInteger).GetMethod(nameof(BigInteger)).Unreflect&lt;ToByteArray&gt;();
BigInteger i = 10;
var array = toByteArray(ref i);
</code></pre>
<p>If method contains <strong>ref</strong> our <strong>our</strong> parameter then then it is possible to use custom delegate, <em>Function</em> or <em>Procedure</em>. The following example demonstrates how to use <em>Function</em> to call a method with <strong>out</strong> parameter.</p>
<pre><code class="lang-csharp">using DotNext.Reflection;

Function&lt;(string text, decimal result), bool&gt; tryParse = typeof(decimal).GetMethod(nameof(decimal.TryParse), new[]{typeof(string), typeof(decimal).MakeByRefType()}).Unreflect&lt;Function&lt;(string, decimal), bool&gt;&gt;();

(string text, decimal result) args = tryParse.ArgList();
args.text = &quot;42&quot;;
tryParse(args);
decimal v = args.result;    //v == 42M
</code></pre>
<p><em>args</em> value passed into <em>Function</em>  instance by reference and contains all necessary arguments in the form of value tuple.</p>
<p>Let's assume than type of <code>text</code> parameter is not known at compile time or unreachable from source code because the type is declared in external library and has <strong>internal</strong> visibility modifier. In this case, the type of such parameter can be replaced with <strong>object</strong> data type. Of course, it will affect performance but still be much faster than classic .NET reflection.</p>
<pre><code class="lang-csharp">using DotNext.Reflection;

Function&lt;(object text, decimal result), bool&gt; tryParse = typeof(decimal).GetMethod(nameof(decimal.TryParse), new[]{typeof(string), typeof(decimal).MakeByRefType()}).Unreflect&lt;Function&lt;(object, decimal), bool&gt;&gt;();

(object text, decimal result) args = tryParse.ArgList();
args.text = &quot;42&quot;;
tryParse(args);
decimal v = args.result;    //v == 42M
</code></pre>
<h1 id="field">Field</h1>
<p>Managed pointer to the static or instance field can obtained from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.fieldinfo">FieldInfo</a> using <code>Unreflect</code> extension method declared in <a href="../../api/DotNext.Reflection.Reflector.html">Reflector</a> class. This feature gives the power to work with field values using Reflection without performance loss.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Managed pointer to the field is mutable even if field is <strong>readonly</strong>. As a result, you can modify value of such field. It is responsibility of the developer to control access to read-only fields.</p>
</div>
<p>This is not the only way to obtain direct access to the field. <a href="../../api/DotNext.Reflection.Field-1.html">Field&lt;V&gt;</a> and <a href="../../api/DotNext.Reflection.Field-2.html">Field&lt;T,V&gt;</a> that can be returned by <a href="../../api/DotNext.Reflection.Type-1.Field-1.html">Type&lt;T&gt;.Field&lt;T&gt;</a> provide access to static and field value respectively.</p>
<p>The following example demonstrates how to obtain managed pointer to the static and instance fields:</p>
<pre><code class="lang-csharp">using DotNext.Reflection;
using System.Reflection;

class MyClass
{
	private static long StaticField;

	private string instanceField;

	public MyClass(string str) =&gt; instanceField = str;
}

//change value of static field
ref long staticField = typeof(MyClass).GetField(&quot;StaticField&quot;, BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly).Unreflect&lt;long&gt;();
staticField = 42L;

//change value of instance field
var obj = new MyClass();
ref string instanceField = obj.GetClass().GetField(&quot;instanceField&quot;, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly).Unreflect&lt;string&gt;(obj);
instanceField = &quot;Hello, world&quot;;
</code></pre>
<h1 id="performance">Performance</h1>
<p>Invocation of members through special delegates is not a free lunch: you pay for passing arguments through the stack. But it still much faster than classic .NET Reflection. The following list describes performance impact using different approaches to reflection (from fast to slow).</p>
<table>
<thead>
<tr>
<th>Reflective call</th>
<th>Performance</th>
</tr>
</thead>
<tbody>
<tr>
<td>Custom delegate type or predefined delegate type which exactly describes the signature of expected method</td>
<td>the same or comparable to direct call (with nanoseconds overhead)</td>
</tr>
<tr>
<td>Special delegate types</td>
<td>x1,4 slower than direct call</td>
</tr>
<tr>
<td>Special delegate types with one or more unknown parameter types (when <strong>object</strong> used instead of actual type)</td>
<td>x2/x3 slower than direct call</td>
</tr>
<tr>
<td>Classic .NET Reflection</td>
<td>x10/x50 slower than direct call</td>
</tr>
</tbody>
</table>
<p>Read more about performance in <a href="../../benchmarks.html">Benchmarks</a> article.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/sakno/DotNext/blob/gh-pages-2.x/docs/features/reflection/fast.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
