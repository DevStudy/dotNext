<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Clustered ASP.NET Core Microservices | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Clustered ASP.NET Core Microservices | .NEXT ">
    <meta name="generator" content="docfx 2.48.0.0">
    
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="clustered-aspnet-core-microservices">Clustered ASP.NET Core Microservices</h1>

<p>.NEXT provides fully-featured implementation of cluster computing infrastructure for microservices constructed on top of ASP.NET Core. This implementation consists of the following features:</p>
<ul>
<li>Point-to-point messaging between microservices organized through HTTP</li>
<li>Consensus algorithm is Raft and all necessary communication for this algorithm is based on HTTP</li>
<li>Replication according with Raft algorithm is fully supported. In-memory audit trail is used by default.</li>
</ul>
<p>In this implementation, Web application treated as cluster node. The following example demonstrates how to turn ASP.NET Core application into cluster node:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft.Http.Embedding;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class Startup : StartupBase
{
    private readonly IConfiguration configuration;

    public Startup(IConfiguration configuration) =&gt; this.configuration = configuration;

    public override void Configure(IApplicationBuilder app)
    {
        app.UseConsensusProtocolHandler();	//informs that processing pipeline should handle Raft-specific requests
    }

    public override void ConfigureServices(IServiceCollection services)
    {
        services.BecomeClusterMember(configuration[&quot;memberConfig&quot;]);	//registers all necessary services required for normal cluster node operation
    }
}

</code></pre>
<p>Raft algorithm requires dedicated HTTP endpoint for internal purposes. There are two possible ways to expose necessary endpoint:</p>
<ul>
<li><strong>Hosted Mode</strong> exposes internal endpoint at different port because dedicated <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.iwebhost">Web Host</a> is used</li>
<li><strong>Embedded Mode</strong> exposes internal endpoint at the same port as underlying web application</li>
</ul>
<p>The necessary mode depends on your requirements and network environment.</p>
<h1 id="dependency-injection">Dependency Injection</h1>
<p>Web application component can request the following service from ASP.NET Core DI container:</p>
<ul>
<li><a href="../../api/DotNext.Net.Cluster.ICluster.html">ICluster</a></li>
<li><a href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftCluster.html">IRaftCluster</a> represents Raft-specific version of <code>ICluster</code> interface</li>
<li><a href="../../api/DotNext.Net.Cluster.Messaging.IMessageBus.html">IMessageBus</a> for point-to-point messaging between nodes</li>
<li><a href="../../api/DotNext.Net.Cluster.ICluster.html">IExpandableCluster</a> for tracking changes in cluster membership</li>
<li><a href="../../api/DotNext.Net.Cluster.Replication.IReplicationCluster-1.html">IReplicationCluster&lt;IRaftLogEntry&gt;</a> to work with audit trail used for replication. <a href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftLogEntry.html">IRaftLogEntry</a> is Raft-specific representation of the record in the audit trail</li>
<li><a href="../../api/DotNext.Net.Cluster.Replication.IReplicationCluster.html">IReplicationCluster</a> to work with audit trail in simplified manner</li>
</ul>
<h1 id="configuration">Configuration</h1>
<p>The application should be configured properly to work as a cluster node. The following JSON represents example of configuration:</p>
<pre><code class="lang-json">{
	&quot;partitioning&quot; : false,
	&quot;lowerElectionTimeout&quot; : 150,
	&quot;upperElectionTimeout&quot; : 300,
	&quot;members&quot; : [&quot;http://localhost:3262&quot;, &quot;http://localhost:3263&quot;, &quot;http://localhost:3264&quot;],
	&quot;metadata&quot; :
	{
		&quot;key&quot;: &quot;value&quot;
	},
	&quot;allowedNetworks&quot; : [&quot;127.0.0.0&quot;, &quot;255.255.0.0/16&quot;, &quot;2001:0db9::1/64&quot;],
	&quot;hostAddressHint&quot; : &quot;192.168.0.1&quot;,
	&quot;requestJournal&quot; :
	{
		&quot;memoryLimit&quot;: 5,
		&quot;expiration&quot;: &quot;00:00:10&quot;,
		&quot;pollingInterval&quot; : &quot;00:01:00&quot;
	},
	&quot;resourcePath&quot; : &quot;/cluster-consensus/raft&quot;,
	&quot;port&quot; : 3262,
	&quot;heartbeatThreshold&quot; : 0.5
}
</code></pre>
<table>
<thead>
<tr>
<th>Configuration parameter</th>
<th>Required</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>partitioning</td>
<td>No</td>
<td>false</td>
<td><code>true</code> if partitioning supported. In this case, each cluster partition may have its own leader, i.e. it is possible to have more that one leader for external observer. However, single partition cannot have more than 1 leader. <code>false</code> if partitioning is not supported and only one partition with majority of nodes can have leader. Note that cluster may be totally unavailable even if there are operating members presented</td>
</tr>
<tr>
<td>lowerElectionTimeout, upperElectionTimeout</td>
<td>No</td>
<td>150, 300</td>
<td>Defines range for election timeout which is picked randomly inside of it for each cluster member. If cluster node doesn't receive heartbeat from leader node during this timeout then it becomes a candidate and start a election. The recommended value for  <em>upperElectionTimeout</em> is <code>2 X lowerElectionTimeout</code></td>
</tr>
<tr>
<td>members</td>
<td>Yes</td>
<td>N/A</td>
<td>An array of all cluster nodes. This list must include local node. DNS name cannot be used as host name in URL except <code>localhost</code>. Only IP address is allowed</td>
</tr>
<tr>
<td>allowedNetworks</td>
<td>No</td>
<td>Empty list which means that all networks are allowed</td>
<td>List of networks with other nodes which a part of single cluster. This property can be used to restrict unathorized requests to the internal endpoint responsible for handling Raft messages</td>
</tr>
<tr>
<td>metadata</td>
<td>No</td>
<td>empty dictionary</td>
<td>A set of key/value pairs to be associated with cluster node. The metadata is queriable through <code>IClusterMember</code> interface</td>
</tr>
<tr>
<td>openConnectionForEachRequest</td>
<td>No</td>
<td>false</td>
<td><code>true</code> to create TCP connection every time for each outbound request. <code>false</code> to use HTTP KeepAlive</td>
</tr>
<tr>
<td>clientHandlerName</td>
<td>No</td>
<td>raftClient</td>
<td>The name to be passed into <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.ihttpmessagehandlerfactory">IHttpMessageHandlerFactory</a> to create <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpmessageinvoker">HttpMessageInvoker</a> used by Raft client code</td>
</tr>
<tr>
<td>resourcePath</td>
<td>No</td>
<td>/cluster-consensus/raft</td>
<td>This configuration parameter is relevant for Embedded Mode only. It defines relative path to the endpoint responsible for handling internal Raft messages</td>
</tr>
<tr>
<td>port</td>
<td>No</td>
<td>32999</td>
<td>This configuration is relevant for Hosted Mode only. It defines the port number that the internal endpoint handler is listening to.</td>
</tr>
<tr>
<td>requestJournal:memoryLimit</td>
<td>No</td>
<td>10</td>
<td>The maximum amount of memory (in MB) utilized by internal buffer used to track duplicate messages</td>
</tr>
<tr>
<td>requestJournal:expiration</td>
<td>No</td>
<td>00:00:10</td>
<td>The eviction time of the record containing unique request identifier</td>
</tr>
<tr>
<td>requestJournal:pollingInterval</td>
<td>No</td>
<td>00:01:00</td>
<td>Gets the maximum time after which the buffer updates its memory statistics</td>
</tr>
<tr>
<td>hostAddressHint</td>
<td>No</td>
<td>N/A</td>
<td>Allows to specify real IP address of the host where cluster node launched. Usually it is needed when node executed inside of Docker container. If this parameter is not specified then cluster node may fail to detect itself because network interfaces inside of Docker container have different addresses in comparison with real host network interfaces. The value can be defined at container startup time, e.g. <code>docker container run -e &quot;member-config:hostAddressHint=$(hostname -i)&quot;</code></td>
</tr>
<tr>
<td>heartbeatThreshold</td>
<td>No</td>
<td>0.5</td>
<td>Specifies frequency of heartbeat messages generated by leader node to inform follower nodes about its leadership. The range is (0, 1). The lower the value means that the messages are generated more frequently and vice versa.</td>
</tr>
<tr>
<td>protocolVersion</td>
<td>No</td>
<td><code>auto</code></td>
<td>HTTP protocol version that should be used for communication between members. Possible values are <code>auto</code>, <code>http1</code>, <code>http2</code></td>
</tr>
</tbody>
</table>
<p><code>requestJournal</code> configuration section is rarely used and useful for high-load scenario only.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Usually, real-world ASP.NET Core application hosted on <code>0.0.0.0</code>(IPv4) or <code>::</code>(IPv6). When testing locally, use explicit loopback IP instead of <code>localhost</code> as host name for all nodes in <code>members</code> section.</p>
</div>
<p>Choose <code>lowerElectionTimeout</code> and <code>upperElectionTimeout</code> according with the quality of your network. If values are small then you get frequent elections and migration of leader node.</p>
<h2 id="runtime-hook">Runtime Hook</h2>
<p>The service implementing <code>IRaftCluster</code> is registered as singleton service. The service starts receiving Raft-specific messages immediately. Therefore, you can loose some events raised by the service such as <code>LeaderChanged</code> at starting point. To avoid that, you can implement <a href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftClusterConfigurator.html">IRaftClusterConfigurator</a> interface and register implementation as singleton.</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft;
using System.Collections.Generic;

internal sealed class ClusterConfigurator : IRaftClusterConfigurator
{
	private static void LeaderChanged(ICluster cluster, IClusterMember leader) {}

	void IRaftClusterConfigurator.Initialize(IRaftCluster cluster, IDictionary&lt;string, string&gt; metadata)
	{
		metadata[&quot;key&quot;] = &quot;value&quot;;
		cluster.LeaderChanged += LeaderChanged;
	}

	void IRaftClusterConfigurator.Shutdown(IRaftCluster cluster)
	{
		cluster.LeaderChanged -= LeaderChanged;
	}
}
</code></pre>
<p>Additionally, the hook can be used to modify metadata of the local cluster member.</p>
<h2 id="http-client-behavior">HTTP Client Behavior</h2>
<p>.NEXT uses <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient">HttpClient</a> for communication between cluster nodes. In .NET Standard, the only available HTTP handler is <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclienthandler">HttpClientHandler</a>. It has inconsistent behavior on different platforms because relies on <em>libcurl</em>. Raft implementation uses <code>Timeout</code> property of <code>HttpClient</code> to establish request timeout. It is always defined as <code>upperElectionTimeout</code> by .NEXT infrastructure. To demonstrate inconsistent behavior let's introduce three cluster nodes: <em>A</em>, <em>B</em> and <em>C</em>. <em>A</em> and <em>B</em> have been started except <em>C</em>:</p>
<ul>
<li>On Windows the leader will not be elected even though the majority is present - 2 of 3 nodes are available. This is happening because Connection Timeout is equal to Response Timeout, which is equal to <code>upperElectionTimeout</code>.</li>
<li>On Linux everything is fine because Connection Timeout less than Response Timeout</li>
</ul>
<p>It is not possible to specify these timeouts separately for <code>HttpClientHandler</code> as well as use <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler">SocketsHttpHandler</a> directly in library code because this class doesn't exist in .NET Standard. However, solution exists and presented by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.ihttpmessagehandlerfactory">IHttpMessageHandlerFactory</a>. You can implement this interface manually and register its implementation as singleton. .NEXT tries to use this interface if it is registered as a factory of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpmessageinvoker">HttpMessageInvoker</a>. The following example demonstrates how to implement this interface and create platform-independent version of message invoker:</p>
<pre><code class="lang-csharp">using System;
using System.Net.Http;

internal sealed class RaftClientHandlerFactory : IHttpMessageHandlerFactory
{
	public HttpMessageHandler CreateHandler(string name) =&gt; new SocketsHttpHandler { ConnectTimeout = TimeSpan.FromMilliseconds(100) };
}
</code></pre>
<p>In practice, <code>ConnectTimeout</code> should be equal to <code>lowerElectionTimeout</code> configuration property. Note that <code>name</code> parameter is equal to the <code>clientHandlerName</code> configuration property when handler creation is requested by Raft implementation.</p>
<h1 id="hosted-mode">Hosted Mode</h1>
<p>This mode allows to create separated <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.iwebhost">Web Host</a> used for hosting Raft-specific stuff. As a result, Raft implementation listens on the port that differs from the port of underlying Web application. The following example demonstrates how to write <em>Startup</em> class for hosted mode:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft.Http.Hosting;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

internal sealed class Startup : StartupBase
{
	private readonly IConfiguration configuration;

	public WebApplicationSetup(IConfiguration configuration) =&gt; this.configuration = configuration;

	public override void Configure(IApplicationBuilder app)
	{

	}

	public override void ConfigureServices(IServiceCollection services)
	{
		services.BecomeClusterMember(configuration);
	}
}
</code></pre>
<p>Note that <code>BecomeClusterMember</code> declared in <a href="../../api/DotNext.Net.Cluster.Consensus.Raft.Http.Hosting.html">DotNext.Net.Cluster.Consensus.Raft.Http.Hosting</a> namespace.</p>
<p>By default, .NEXT uses Kestrel web server to serve Raft requests. However, it is possible to use manually constructed <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.iwebhost">IWebHost</a>. In this case, <code>port</code> configuration property will be ignored.</p>
<h1 id="embedded-mode">Embedded Mode</h1>
<p>Embedded mode shares the same <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.iwebhost">Web Host</a> and port with underlying Web Application. To serve Raft-specific requests the implementation uses dedicated endpoint <code>/cluster-consensus/raft</code> that can be changed through configuration parameter. The following example demonstrates how to setup embedded mode:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft.Http.Embedding;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class Startup : StartupBase
{
    private readonly IConfiguration configuration;

    public Startup(IConfiguration configuration) =&gt; this.configuration = configuration;

    public override void Configure(IApplicationBuilder app)
    {
        app.UseConsensusProtocolHandler();	//informs that processing pipeline should handle Raft-specific requests
    }

    public override void ConfigureServices(IServiceCollection services)
    {
        services.BecomeClusterMember(configuration[&quot;memberConfig&quot;]);	//registers all necessary services required for normal cluster node operation
    }
}
</code></pre>
<p>Note that <code>BecomeClusterMember</code> declared in <a href="../../api/DotNext.Net.Cluster.Consensus.Raft.Http.Embedding.html">DotNext.Net.Cluster.Consensus.Raft.Http.Embedding</a> namespace.</p>
<p><code>UseConsensusProtocolHandler</code> method should be called before registration of any authentication/authorization middleware.</p>
<h1 id="redirection-to-leader">Redirection to Leader</h1>
<p>Now cluster of ASP.NET Core applications can receive requests from outside. Some of these requests may be handled by leader node only. .NEXT cluster programming model provides a way to automatically redirect request to leader node if it was originally received by follower node. The redirection is organized with help of <em>307 Temporary Redirect</em> status code. Every follower node knows the actual address of the leader node. If cluster or its partition doesn't have leader then node returns <em>503 Service Unavailable</em>.</p>
<p>Automatic redirection is provided by <a href="../../api/DotNext.Net.Cluster.Consensus.Raft.Http.LeaderRouter.html">LeaderRouter</a> class. You can specify endpoint that should be handled by leader node with <code>RedirectToLeader</code> method.</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft.Http;
using DotNext.Net.Cluster.Consensus.Raft.Http.Embedding;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class Startup : StartupBase
{
    private readonly IConfiguration configuration;

    public Startup(IConfiguration configuration) =&gt; this.configuration = configuration;

    public override void Configure(IApplicationBuilder app)
    {
        app.UseConsensusProtocolHandler()
			.RedirectToLeader(&quot;/endpoint1&quot;)
			.RedirectToLeader(&quot;/endpoint2&quot;);
    }

    public override void ConfigureServices(IServiceCollection services)
    {
        services.BecomeClusterMember(configuration);
    }
}
</code></pre>
<p>This redirection can be transparent to actual client if you use reverse proxy server such as NGINX. Reverse proxy can automatically handle redirection without returning control to the client.</p>
<h2 id="custom-redirections">Custom Redirections</h2>
<p>It is possible to change default behavior of redirection where <em>301 Moved Permanently</em> status code is used. You can pass custom implementation into the optional parameter of <code>RedirectToLeader</code> method.</p>
<p>The following example demonstrates how to return <em>404 Not Found</em> and location of Leader node as its body.</p>
<pre><code class="lang-csharp">private static Task CustomRedirection(HttpResponse response, Uri leaderUri)
{
    response.StatusCode = StatusCodes.Status404NotFound;
    return response.WriteAsync(leaderUri.AbsoluteUri);
}

public override void Configure(IApplicationBuilder app)
{
    app.UseConsensusProtocolHandler()
        .RedirectToLeader(&quot;/endpoint1&quot;, redirection: CustomRedirection);
}
</code></pre>
<p>The customized redirection should be as fast as possible and don't block the caller.</p>
<h2 id="port-mapping">Port mapping</h2>
<p>Redirection mechanism trying to construct valid URI of the leader node based on its actual IP address. Identification of the address is not a problem unlike port number. The infrastructure cannot use the port if its <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.webhost">WebHost</a> because of Hosted Mode or the port from the incoming <code>Host</code> header because it can be rewritten by reverse proxy. The only way is to use the inbound port of the TCP listener responsible for handling all incoming HTTP requests. It is valid for the non-containerized environment. Inside of the container the ASP.NET Core application port is mapped to the externally visible port which not always the same. In this case you can specify port for redirections explicitly as follows:</p>
<pre><code class="lang-csharp">public override void Configure(IApplicationBuilder app)
{
    app.UseConsensusProtocolHandler()
      .RedirectToLeader(&quot;/endpoint1&quot;, applicationPortHint: 3265);
}
</code></pre>
<h1 id="messaging">Messaging</h1>
<p>.NEXT extension for ASP.NET Core supports messaging beween nodes through HTTP out-of-the-box. However, the infrastructure don't know how to handle custom messages. Therefore, if you want to utilize this functionality then you need to implement <a href="../../api/DotNext.Net.Cluster.Messaging.IMessageHandler.html">IMessageHandler</a> interface.</p>
<p>Messaging inside of cluster supports redirection to the leader as well as for external client. But this mechanism implemented differently and represented by the following methods declared in <a href="../../api/DotNext.Net.Cluster.Messaging.IMessageBus.html">IMessageBus</a> interface:</p>
<ul>
<li><code>SendMessageToLeaderAsync</code> to send <em>Request-Reply</em> message to the leader</li>
<li><code>SendSignalToLeaderAsync</code> to send <em>One Way</em> message to the leader</li>
</ul>
<h1 id="replication">Replication</h1>
<p>Raft algorithm requires additional persistent state in order to basic audit trail. This state is represented by <a href="../../api/DotNext.Net.Cluster.Consensus.Raft.IPersistentState.html">IPersistentState</a> interface. By default, it is implemented as <a href="https://sakno.github.io/dotNext/api/DotNext.Net.Cluster.Consensus.Raft.InMemoryAuditTrail.html">in-memory storage</a> which is suitable only for applications that doesn't have replicated state. If your application has it then use <a href="../../api/DotNext.Net.Cluster.Consensus.Raft.PersistentState.html">PersistentState</a> class or implement this interface manually and use reliable storage such as disk. The implementation can be injected explicitly via <code>AuditTrail</code> property of <a href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftCluster.html">IRaftCluster</a> interface or implicitly via Dependency Injection. The explicit should be done inside of the user-defined implementation of <a href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftClusterConfigurator.html">IRaftClusterConfigurator</a> interface registered as a singleton service in ASP.NET Core application. The implicit injection requires registration of singleton service which implements <a href="../../api/DotNext.Net.Cluster.Consensus.Raft.IPersistentState.html">IPersistentState</a> interface.</p>
<h2 id="reliable-state">Reliable State</h2>
<p>Information about reliable persistent state which uses disk for storing write ahead log located in the separated <a href="wal.html">article</a>.</p>
<h1 id="metrics">Metrics</h1>
<p>It is possible to measure runtime metrics of Raft node internals using <a href="https://sakno.github.io/dotNext/api/DotNext.Net.Cluster.Consensus.Raft.Http.HttpMetricsCollector.html">HttpMetricsCollector</a> class. The reporting mechanism is agnostic  to the underlying metrics delivery library such as <a href="https://github.com/AppMetrics/AppMetrics">AppMetrics</a>.</p>
<p>The class contains methods that are called automatically. You can override them and implement necessary reporting logic. By default, these methods do nothing.</p>
<p>The metrics collector should be registered as singleton service using Dependency Injection. However, the type of the service used for registration should of <a href="https://sakno.github.io/dotNext/api/DotNext.Net.Cluster.Consensus.Raft.MetricsCollector.html">MetricsCollector</a> type.</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft;
using DotNext.Net.Cluster.Consensus.Raft.Http;
using DotNext.Net.Cluster.Consensus.Raft.Http.Embedding;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class MyCollector : HttpMetricsCollector
{
	public override void ReportResponseTime(TimeSpan value)
    {
		//report response time of the cluster member
    } 

	public override void ReportBroadcastTime(TimeSpan value)
    {
		//report broadcast time measured during sending the request to all cluster members
    }
}

sealed class Startup : StartupBase
{
    private readonly IConfiguration configuration;

    public Startup(IConfiguration configuration) =&gt; this.configuration = configuration;

    public override void Configure(IApplicationBuilder app)
    {
        app.UseConsensusProtocolHandler()
			.RedirectToLeader(&quot;/endpoint1&quot;)
			.RedirectToLeader(&quot;/endpoint2&quot;);
    }

    public override void ConfigureServices(IServiceCollection services)
    {
		services.AddSingleton&lt;MetricsCollector, MyCollector&gt;().BecomeClusterMember(configuration);
    }
}
</code></pre>
<p>It is possible to derive directly from <a href="https://sakno.github.io/dotNext/api/DotNext.Net.Cluster.Consensus.Raft.MetricsCollector.html">MetricsCollector</a> if you don't need to receive metrics related to HTTP-specific implementation of Raft algorithm.</p>
<p>Implementation of reporting method should fast as possible or asynchronous. If reporting causes I/O operations synchronously then it affects the overall performance of Cluster library internals such as communication with other cluster members which is time-critical.</p>
<h1 id="example">Example</h1>
<p>There is Raft playground represented by RaftNode application. You can find this app <a href="https://github.com/sakno/dotNext/tree/develop/src/examples/RaftNode">here</a>. This playground allows to test Raft consensus protocol in real world. Each instance of launched application represents cluster node. All nodes can be started using the following script:</p>
<pre><code class="lang-bash">cd &lt;dotnext&gt;/src/examples/RaftNode
dotnet run -- 3262
dotnet run -- 3263
dotnet run -- 3264
</code></pre>
<p>Every instance should be launched in separated Terminal session. After that, you will see diagnostics messages in <code>stdout</code> about election process. Press <em>Ctrl+C</em> in the window related to the leader node and ensure that new leader will be elected.</p>
<p>Optionally, you can test replication powered by persistent WAL and <a href="../../api/DotNext.Net.Cluster.Replication.WriteConcern.html">WriteConcern</a>. To do that, you need to specify the name of folder which is used to store Write Ahead Log files</p>
<pre><code class="lang-bash">cd &lt;dotnext&gt;/src/examples/RaftNode
dotnet run -- 3262 node1
dotnet run -- 3263 node2
dotnet run -- 3264 node3
</code></pre>
<p>Now you can see replication messages in each Terminal window. The replicated state stored in the <code>node1</code>, <code>node2</code> and <code>node3</code> folders. You can restart one of the nodes and make sure that its state is recovered correctly.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/sakno/DotNext/blob/gh-pages/docs/features/cluster/aspnetcore.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
