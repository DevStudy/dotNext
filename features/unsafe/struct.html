<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Structured Memory Access | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Structured Memory Access | .NEXT ">
    <meta name="generator" content="docfx 2.48.0.0">
    
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="structured-memory-access">Structured Memory Access</h1>

<p><a href="../../api/DotNext.Runtime.InteropServices.UnmanagedMemory-1.yml">UnmanagedMemory&lt;T&gt;</a> is a safe way to allocate structured data in unmanaged memory of any blittable value type. There are two possible usages of this type:</p>
<ol>
<li>Allocation of an array in unmanaged memory</li>
<li>Allocation of blittable value type in unmanaged memory</li>
</ol>
<p>Instance of <code>UnmanagedMemory&lt;T&gt;</code> is a managed object which maintains a pointer to the allocated unmanaged memory. Therefore, it can be reclaimed by GC. In that case, finalizer method releases unmanaged memory referenced by such object. Additionally, it is possible to call <code>Dispose()</code> method directly to release unmanaged memory.</p>
<h1 id="unmanaged-array">Unmanaged Array</h1>
<p>The following example demonstrates how to allocate array in unmanaged memory.</p>
<pre><code class="lang-csharp">using DotNext.Runtime.InteropServices;

using(var memory = new UnmanagedMemory&lt;double&gt;(10)) //array of 10 elements
{
    Span&lt;double&gt; array = memory;
    //element set
    array[0] = 10;
    array[1] = 30;
    //obtains a pointer to the array element with index 1
    Pointer&lt;double&gt; ptr = array;
    ptr += 1;  
    //change array element
    ptr.Value = 30;
    //copy to managed heap
    double[] managedArray = array.ToArray();
}
</code></pre>
<p>Unmanaged array supports interoperation with managed arrays and streams.</p>
<p><strong>foreach</strong> loop is also supported because <code>UnmanagedMemory&lt;T&gt;</code> is convertible into <a href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1">Span</a>:</p>
<pre><code class="lang-csharp">using DotNext.Runtime.InteropServices;

using(var array = new UnmanagedMemory&lt;double&gt;(10))
{
    array[0] = 10;
    array[1] = 30;
    foreach(var item in array.Span)
        Console.WriteLine(item);
}
</code></pre>
<p>The memory can be resized on-the-fly. Resizing causes re-allocation of the memory with the copying of the elements from the original location. The new size of the array can be defined using <code>Reallocate</code> method.</p>
<pre><code class="lang-csharp">using DotNext.Runtime.InteropServices;

using(var memory = new UnmanagedMemory&lt;double&gt;(10)) //memory.Length == 10L
{
    Span&lt;double&gt; array = memory;
    array[0] = 10;
    array[1] = 30;
    memory.Reallocate(20);  //causes re-allocation of the array
    array = memory;
    var i = array[0] + array[1];    //i == 40
}
</code></pre>
<p><code>Reallocate</code> method accepts the new length of the array, not size in bytes.</p>
<p>Memory span and typed pointer are not valid after re-allocation. You must ensure that consumers obtain a fresh version of there structures every time when working with unmanaged memory.</p>
<h1 id="struct-allocation">struct Allocation</h1>
<p>The same type can be used to allocate single value of blittable value type in unmanaged memory. To do that, you can specify length of <em>1</em> when creating instance of <code>UnmanagedMemory&lt;T&gt;</code> or use <code>Box</code> static method to copy value from stack into unmanaged memory.</p>
<p>The simpliest way to understand this concept is to provide the following example in C:</p>
<pre><code class="lang-c">#include &lt;stdlib.h&gt;

typedef struct {
    double image;
    double real;
} complex;

complex *c = malloc(sizeof(complex));
c-&gt;image = 20;
c-&gt;real = 30;
free(c);
</code></pre>
<p>The equivalent code in C# using <code>UnmanagedMemory&lt;T&gt;</code> is</p>
<pre><code class="lang-csharp">using DotNext.Runtime.InteropServices;

struct Complex
{
    public double Image, Real;
}

using(var memory = new UnmanagedMemory&lt;Complex&gt;(1))
{
    memory.Pointer.Image = 20;
    memory.Pointer.Real = 30;
}
</code></pre>
<p>Additionally, it is possible to box value type into unmanaged memory:</p>
<pre><code class="lang-csharp">using DotNext.Runtime.InteropServices;

struct Complex
{
    public double Image, Real;
}

using(var c = UnmanagedMemory&lt;Complex&gt;.Box(new Complex { Image = 20, Real = 30 }))
{
}
</code></pre>
<p>Direct memory manipulations available using typed pointer:</p>
<pre><code class="lang-csharp">using DotNext.Runtime.InteropServices;

struct Complex
{
    public double Image, Real;
}

using(var c = UnmanagedMemory&lt;Complex&gt;.Box(new Complex { Image = 20, Real = 30 }))
{
    Pointer&lt;double&gt; pImage = c.Pointer.As&lt;double&gt;();
    Pointer&lt;double&gt; pReal = pImage + 1;
    pImage.Value = 1;
    pReal.Value = 2;
}
</code></pre>
<p>Byte-level manipulations can be organized in two ways:</p>
<ol>
<li>Through <code>Bytes</code> property which provides memory span for bytes</li>
<li>Through <code>Pointer</code> at its ability to reinterpret its type</li>
</ol>
<pre><code class="lang-csharp">using DotNext.Runtime.InteropServices;
using System;

var id = Guid.NewGuid();

using(var memory = UnmanagedMemory&lt;Guid&gt;.Box(id))
{
    Span&lt;byte&gt; bytes = memory.Bytes;
    Pointer&lt;byte&gt; ptr = memory.Pointer.As&lt;byte&gt;();
}
</code></pre>
<h1 id="unmanaged-memory-pool">Unmanaged Memory Pool</h1>
<p>.NET standard library provides a concept of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.memorymanager-1">memory manager</a> which represents an owner of continuous block of memory. By default, it is implemented by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.memorypool-1">MemoryPool</a>. The block of memory can be obtained from the manager in the form of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.memory-1">Memory&lt;T&gt;</a> value type which is compatible with async methods. Unfortunately, the unmanaged memory controlled by <code>UnmanagedMemory&lt;T&gt;</code> class from .NEXT library is not compatible with <code>Memory&lt;T&gt;</code> value type.</p>
<p>This gap is closed by <a href="https://sakno.github.io/dotNext/api/DotNext.Buffers.UnmanagedMemoryPool-1.html">UnmanagedMemoryPool&lt;T&gt;</a> class which allows to allocate a block of unmanaged memory in full compliance with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.imemoryowner-1">IMemoryOwner&lt;T&gt;</a> interface. Now it is possible to represent unmanaged memory as <code>Memory&lt;T&gt;</code> value type.</p>
<div class="TIP">
<h5>Tip</h5>
<p><code>UnmanagedMemoryPool&lt;T&gt;</code> is preferred way to work with unmanaged memory and replacement for <code>UnmanagedMemory</code> and <code>UnmanagedMemory&lt;T&gt;</code> classes from .NEXT. However, re-allocation of unmanaged memory is not supported.</p>
</div>
<p>The block of unmanaged memory can be allocated using static method <code>Allocate</code> that has <a href="https://sakno.github.io/dotNext/api/DotNext.Buffers.IUnmanagedMemoryOwner-1.html">IUnmanagedMemoryOwner&lt;T&gt;</a> return type. This interface is derived from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.imemoryowner-1">IMemoryOwner&lt;T&gt;</a> so the memory block can be easily represented as <code>Memory&lt;T&gt;</code> value type.</p>
<p>If you need to work with unmanaged memory as with memory pool then it is possible to instantiate <code>UnmanagedMemoryPool&lt;T&gt;</code> class and use it in the same manner as <code>MemoryPool&lt;T&gt;</code> from .NET standard library.</p>
<p>The following example demonstrates how to allocate a block of unmanaged memory and wrap it into <code>Memory&lt;T&gt;</code> value type:</p>
<pre><code class="lang-csharp">using DotNext.Buffers;
using System.Buffers;

using(IUnmanagedMemoryOwner&lt;long&gt; owner = UnmanagedMemoryPool&lt;long&gt;.Allocate(12))
{
  Memory&lt;long&gt; memory = owner.Memory;
  memory.Span[0] = 42L;
}
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/sakno/DotNext/blob/gh-pages-2.x/docs/features/unsafe/struct.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
