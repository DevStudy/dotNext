<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Value Delegates | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Value Delegates | .NEXT ">
    <meta name="generator" content="docfx 2.48.0.0">
    
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="value-delegates">Value Delegates</h1>

<p>Value Delegates provide general-purpose, CLS compliant, allocation-free, lightweight callback capability to .NET languages. They can be used as regular .NET delegates but have different properties:</p>
<ol>
<li>Value Delegate is a value type and don't require heap allocation</li>
<li>Multicast is not supported</li>
<li>Value Delegate cannot be used for declaration of events</li>
<li>It is not possible to declare custom Value Delegate</li>
</ol>
<p>.NEXT provides ready-to-use set of Value Delegates:</p>
<ol>
<li><a href="../../api/DotNext.ValueAction.html">ValueAction</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action">Action</a></li>
<li><a href="../../api/DotNext.ValueAction-1.html">ValueAction&lt;T&gt;</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action-1">Action&lt;T&gt;</a></li>
<li><a href="../../api/DotNext.ValueAction-2.html">ValueAction&lt;T1,T2&gt;</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action-2">Action&lt;T1,T2&gt;</a></li>
<li><a href="../../api/DotNext.ValueAction-3.html">ValueAction&lt;T1,T2,T3&gt;</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action-3">Action&lt;T1,T2,T3&gt;</a></li>
<li><a href="../../api/DotNext.ValueAction-4.html">ValueAction&lt;T1,T2,T3,T4&gt;</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action-4">Action&lt;T1,T2,T3,T4&gt;</a></li>
<li><a href="../../api/DotNext.ValueAction-5.html">ValueAction&lt;T1,T2,T3,T4,T5&gt;</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.action-5">Action&lt;T1,T2,T3,T4&gt;</a></li>
<li><a href="../../api/DotNext.ValueFunc-1.html">ValueFunc&lt;R&gt;</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.func-1">Func&lt;R&gt;</a></li>
<li><a href="../../api/DotNext.ValueFunc-2.html">ValueFunc&lt;T,R&gt;</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.func-2">Func&lt;T,R&gt;</a></li>
<li><a href="../../api/DotNext.ValueFunc-3.html">ValueFunc&lt;T1,T2,R&gt;</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.func-3">Func&lt;T1,T2,R&gt;</a></li>
<li><a href="../../api/DotNext.ValueFunc-4.html">ValueFunc&lt;T1,T2,T3,R&gt;</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.func-4">Func&lt;T1,T2,T3,R&gt;</a></li>
<li><a href="../../api/DotNext.ValueFunc-5.html">ValueFunc&lt;T1,T2,T3,T4,R&gt;</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.func-5">Func&lt;T1,T2,T3,T4,R&gt;</a></li>
<li><a href="../../api/DotNext.ValueFunc-6.html">ValueFunc&lt;T1,T2,T3,T4,T5,R&gt;</a> as alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.func-6">Func&lt;T1,T2,T3,T4,T5,R&gt;</a></li>
<li><a href="../../api/DotNext.ValueRefAction-2.html">ValueRefAction&lt;T,TArgs&gt;</a> as alternative to <a href="../../api/DotNext.RefAction-2.html">RefAction&lt;T,TArgs&gt;</a></li>
<li><a href="../../api/DotNext.ValueRefFunc-3.html">ValueRefFunc&lt;T,TArgs,TResult&gt;</a> as alternative to <a href="../../api/DotNext.RefFunc-3.html">RefFunc&lt;T,TArgs,TResult&gt;</a></li>
</ol>
<div class="NOTE">
<h5>Note</h5>
<p>It is recommended to pass Value Delegates by reference using <strong>in</strong> modifier to avoid copying on the stack.</p>
</div>
<p>Value Delegates are convertible with regular delegates in both directions:</p>
<pre><code class="lang-csharp">using DotNext;
using System;

Func&lt;string, int&gt; parse = int.Parse;
//from regular to Value Delegate
ValueFunc&lt;string, int&gt; valueFunc = new ValueFunc&lt;string, int&gt;(parse);
//from Value Delegate to regular
parse = valueFunc.ToDelegate();
</code></pre>
<p>Internally, Value Delegate is operating in two modes:</p>
<ol>
<li><em>Normal</em> mode means that the delegate just holds the pointer to the managed method for subsequent invocations. This mode is enabled only if the method passed into Value Delegate is static without implicitly captured first argument. This is the most profitable mode because the delegate doesn't have any references to the heap.</li>
<li><em>Proxy</em> mode means that the delegate acts as a wrapper for regular .NET delegate. This mode is enabled if the method passed into Value Delegate is instance, abstract or have implicitly captured object. The delegate holds a reference to the regular .NET delegate allocated on the heap.</li>
</ol>
<p>However, <em>proxy</em> mode is not useless and allow to achieve uniformity across API, utilizing both types of delegates:</p>
<pre><code class="lang-csharp">using DotNext;
using System;

public static class ArrayUtils
{
	public static void Sort&lt;T&gt;(T[] array, in ValueFunc&lt;T, T, int&gt; comparer)
	{
		//sorting algorithm
	}

	public static void Sort&lt;T&gt;(T[] array, Func&lt;T, T, int&gt; comparer)
		=&gt; Sort(array, new ValueFunc&lt;T, T, int&gt;(comparer, true));
}
</code></pre>
<p>The second argument of <a href="../../api/DotNext.ValueFunc-3.html">ValueFunc&lt;T1,T2,R&gt;</a> constructor which is <code>true</code> means that it should be created in <em>proxy</em> mode.</p>
<p>C# language has first-class support of .NET regular delegates in the form of the special syntax where method group can be passed into delegate constructor. Value Delegate doesn't have such native compiler support. Therefore, it uses regular .NET delegates for instantiation. If underlying delegate represents static method, its <a href="https://docs.microsoft.com/en-us/dotnet/api/system.delegate.target">Target</a> property is *<em>null</em> then Value Delegate will be created in <em>normal</em> mode. Obviously, the construction of Value Delegate requires memory allocation in the form of regular delegate. However, the created delegate can be reclaimed by GC immediately after instantiation of Value Delegate. Thus, it is recommended to save the created Value Delegate into <code>static readonly</code> as reuse it whenever possible.</p>
<pre><code class="lang-csharp">using DotNext;
using System;

public static class ComparisonUtils
{
	public static readonly ValueFunc&lt;long, long, int&gt; ComparerInt64 = new ValueFunc&lt;long, long, int&gt;(CompareInt64);

	private static int CompareInt64(long x, long y)
	{
		if(x &lt; y)
			return -1;
		if(x &gt; y)
			return 1;
		return 0;
	}
}
</code></pre>
<p>The second <code>bool</code> parameter of Value Deleate constructor is not used because <em>proxy</em> mode should not be forced. The parameter is just a hint and even if it not specified or specified as <code>false</code> then Value Delegate can be constructed as <em>proxy</em> if passed delegate instance doesn't satisfy to the requirements expected by <em>normal</em> mode.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>It is not recommended to create Value Delegates using lambda expression because C# compiler produces hidden closure even if nothing is captured from outer lexical scope. This closure is stored in <em>Target</em> property of the delegate and force <em>proxy</em> mode.</p>
</div>
<p>Invocation of Value Delegate has approximately the same performance as regular .NET delegates. To verify that, check out <a href="../../benchmarks.html">Benchmarks</a>.</p>
<h1 id="compile-time-support">Compile-Time Support</h1>
<p>.NEXT offers optional compile-time support of Value Delegates using <a href="../aug.html">Compile-Time Augmentations</a> feature. This feature helps Roslyn compiler to understand instantiation semantics of Value Delegate and remove creation of regular delegate. Therefore, you don't need to store instance of Value Delegate in <strong>static readonly</strong> field. Instead of this, you can instantiate it in-place.</p>
<p>Let's look at the following code:</p>
<pre><code class="lang-csharp">using DotNext;

private static long Sum(long x, long y) =&gt; x + y;

var sum = new ValueFunc&lt;long, long, long&gt;(Sum);
sum.Invoke(2L, 3L);	//returns 5
</code></pre>
<p>The code looks fine but Roslyn can't understand your intentions because Value Delegates are not known to it. However, it can be compiled successfully with one side-effect: redundant memory allocation. This is happening because the actual compiler code looks like this:</p>
<pre><code class="lang-csharp">using DotNext;

private static long Sum(long x, long y) =&gt; x + y;

var sum = new ValueFunc&lt;long, long, long&gt;(new Func&lt;long, long, long&gt;(Sum));
sum.Invoke(2L, 3L);	//returns 5
</code></pre>
<p>Now you see that <code>ValueFunc</code> constructor accepts instance of regular .NET delegate which is allocated on the heap.</p>
<p>.NEXT Augmented Compilation tells the compiler that this allocation is redundant and pointer to the static method can be passed into Value Delegate directly. The allocation of regular delegate is removed from IL code at compile-time by .NEXT code weaver.</p>
<p>This feature is optional and become available only if .NEXT Augmented Compilation enabled. However, the code above is correct even if augmentations are not enabled for building pipeline. In this case, heap allocation of regular delegate stays in compiled code.</p>
<h1 id="instance-methods">Instance Methods</h1>
<p>Capturing of instance non-abstract methods are not supported in <em>normal</em> mode. However, the early prototype had such support but later it was dropped. The main reason is IL limitation: it is not possible to express <strong>this</strong> argument in uniform way for value and reference type both. This magic is only allowed for virtual calls using <code>.constrained</code> prefix in conjunction with <code>callvirt</code> instruction but not for <code>calli</code> instruction. The second reason is C# compiler which allows to specify static method for open delegate or instance method for closed delegate. There is no syntax for open instance method. As a result, open delegates created for instance methods are used rarely.</p>
<h1 id="dynamically-loaded-assemblies">Dynamically Loaded Assemblies</h1>
<p>The assembly can be loaded dynamically using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext">AssemblyLoadContext</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.appdomain">AppDomain</a> or generated using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder">AssemblyBuilder</a>. The loaded assembly can be unloaded and pointer to the method declared in such assembly becomes invalid. This problem is called <em>dangling pointer</em> which is well known in C/C++ world. The problem is only observed in <em>Normal</em> mode of Value Delegate because this mode operates with method pointer directly. However, the constructor of every Value Delegate that accepts regular .NET delegate is fully protected from this situation. It checks the assembly where the method belongs to. If the assembly is <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.isdynamic">Dynamic</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.reflectiononly">ReflectionOnly</a> or <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.iscollectible">Collectible</a> then Value Delegate swithing into <em>Proxy</em> mode automatically.</p>
<p>The only case that cannot be covered automatically is Compile-Time Support provided by .NEXT Augmented Compilation. The compilation process replaces instantiation of regular .NET delegate with <code>ldftn</code> IL instruction which allows to obtain method pointer. If such Value Delegate will be created and saved into the part of code that cannot be unloaded then you will have a risk to crash the underlying runtime when the assembly containing this method will be unloaded.</p>
<p>So if your application relies on dynamic assembly loading then don't use Augmented Compilation support for Value Delegates.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/sakno/DotNext/blob/gh-pages-2.x/docs/features/core/valued.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
