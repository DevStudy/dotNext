<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Atomic Operations | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Atomic Operations | .NEXT ">
    <meta name="generator" content="docfx 2.48.0.0">
    
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="atomic-operations">Atomic Operations</h1>

<p>Most .NET programming languages provide primitive atomic operations to work with fields with concurrent access. For example, C# <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/volatile">volatile</a> keyword is a language feature for atomic read/write of the marked field. But what if more complex atomic operation is required? Java provides <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicInteger.html">such features</a> at library level, with some overhead associated with object allocation. C# and many other .NET languages support concept of <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref">passing by refence</a> so it is possible to obtain a reference to the field value. This ability allows to avoid overhead of atomic primitives typical to JVM languages. Moreover, extension methods may accept <strong>this</strong> parameter by reference forming the foundation for atomic operations provided  by .NEXT library.</p>
<p>The library provides advanced atomic operations for the following types:</p>
<ul>
<li>Scalar types
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.int64">long</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.int32">int</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.boolean">bool</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.double">double</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.single">float</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.intptr">IntPtr</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types">Reference types</a></li>
</ul>
</li>
<li>One-dimensional arrays</li>
</ul>
<p>Numeric types have the following atomic operations:</p>
<ul>
<li><em>VolatileRead</em></li>
<li><em>VolatileWrite</em></li>
<li><em>IncrementAndGet</em> - atomic increment of the field</li>
<li><em>DecrementAndGet</em> - atomic decrement of the field</li>
<li><em>CompareAndSet</em> - atomic modification of the field based on comparison</li>
<li><em>Add</em> - atomic arithemtic addition</li>
<li><em>GetAndSet</em>, <em>SetAndGet</em> - atomic modification of the field with ability to obtain modified value as a result</li>
<li><em>AccumulateAndGet</em>, <em>GetAndAccumulate</em> - atomic modification of the field where modification logic is based on the supplied value and custom accumulator binary function</li>
<li><em>UpdateAndGet</em>, <em>GetAndUpdate</em> - atomic modification of the field where modification logic is based in the custom unary function</li>
</ul>
<p>Reference types have similar set of atomic operations except arithmetic operations such as increment, decrement and addition.</p>
<h1 id="atomic-operations-for-scalar-types">Atomic operations for scalar types</h1>
<p>Atomic operations are extension methods grouped by specific target scalar types:</p>
<ul>
<li><a href="../../api/DotNext.Threading.AtomicInt32.html">AtomcInt32</a> for <a href="https://docs.microsoft.com/en-us/dotnet/api/system.int32">int</a></li>
<li><a href="../../api/DotNext.Threading.AtomicInt64.html">AtomicInt64</a> for <a href="https://docs.microsoft.com/en-us/dotnet/api/system.int64">long</a></li>
<li><a href="../../api/DotNext.Threading.AtomicSingle.html">AtomicSingle</a> for <a href="https://docs.microsoft.com/en-us/dotnet/api/system.single">float</a></li>
<li><a href="../../api/DotNext.Threading.AtomicDouble.html">AtomicDouble</a> for <a href="https://docs.microsoft.com/en-us/dotnet/api/system.double">double</a></li>
<li><a href="../../api/DotNext.Threading.AtomicIntPtr.html">AtomicIntPtr</a> for <a href="https://docs.microsoft.com/en-us/dotnet/api/system.intptr">IntPtr</a></li>
<li><a href="../../api/DotNext.Threading.AtomicReference.html">AtomicReference</a> for <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types">reference types</a></li>
</ul>
<p>Atomic operations for some data types represented by atomic containers instread of extension methods:</p>
<ul>
<li><a href="../../api/DotNext.Threading.AtomicBoolean.html">AtomicBoolean</a> for <a href="https://docs.microsoft.com/en-us/dotnet/api/system.boolean">bool</a> data type</li>
<li><a href="../../api/DotNext.Threading.AtomicEnum-1.html">AtomicEnum</a> for <strong>enum</strong> data types</li>
</ul>
<p>The following example demonstrates how to use advanced atomic operations</p>
<pre><code class="lang-csharp">using DotNext.Threading;

public class TestClass
{
    private long field;

    public void IncByTwo() =&gt; field.UpdateAndGet(x =&gt; x + 2);   //update field with a sum of its value and constant 2 atomically

    public void IncByTwo2() =&gt; field.Add(2);    //the same effect

    public long Sub(long value) =&gt; field.AccumulateAndGet(value, (current, v) =&gt; current - value); //the same as field -= value but performed atomically
}
</code></pre>
<h1 id="atomic-operations-for-arrays">Atomic operations for arrays</h1>
<p>C# doesn't provide volatile access to array elements syntactically in contrast with volatile fields. .NEXT library provides the same set of atomic operations as for scalar types with a small difference: array atomic operation accept element index as additional argument.</p>
<p>The second approach utilizes extension method.</p>
<pre><code class="lang-csharp">using DotNext.Threading;

var array = new double[10];
var result = array.IncrementAndGet(2);   //2 is an index of array element to be modified
result = array.VolatileRead(2);  //atomic read of array element
array.VolatileWrite(2, 30D);  //atomic modification of array element
</code></pre>
<h1 id="atomic-operations-with-pointers">Atomic operations with pointers</h1>
<p>Working with unmanaged memory in multithreaded application also requires atomic operations and volatile memory access. <a href="../../api/DotNext.Threading.AtomicPointer.html">AtomicPointer</a> provides all necessary functionality as extension methods for <a href="../../api/DotNext.Runtime.InteropServices.Pointer-1.html">Pointer&lt;T&gt;</a> data type.</p>
<h1 id="atomic-access-for-arbitrary-value-types">Atomic access for arbitrary value types</h1>
<p>Volatile memory access is hardware dependent feature. For instance, on x86 atomic read/write can be guaranteed for 32-bit data types only. On x86_64, this guarantee is extended to 64-bit data type. What if you need to have hardware-independent atomic read/write for arbitrary value type? The naive solution is to use <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimploptions#System_Runtime_CompilerServices_MethodImplOptions_Synchronized">Synchronized</a> method. It can be declared in class only, not in value type. If your volatile field declared in value type then you cannot use such kind of methods or you need to create container in the form of the class which requires allocation on the heap.</p>
<p><a href="../../api/DotNext.Threading.Atomic-1.html">Atomic&lt;T&gt;</a> is a container that provides atomic operations for arbitrary value type. The container is value type itself and do not require heap allocation. Memory access to the stored value is organized through software-emulated memory barrier which is portable across CPU architectures. Performance impact is very low. Under heavy lock contention, the access time is ~20-30% faster than Synchronized methods. Check <a href="../../benchmarks.html">Benchmarks</a> for information.</p>
<p>The following example demonstrates how to organize atomic access to field of type <a href="https://docs.microsoft.com/en-us/dotnet/api/system.guid">Guid</a>.</p>
<pre><code class="lang-csharp">using DotNext.Threading;

class MyClass
{
	private Atomic&lt;Guid&gt; id;

	public void GenerateNewId() =&gt; id.Write(Guid.NewGuid());	//Write is atomic

	public bool IsEmptyId 
	{
		get
		{
			id.Read(out var value);	//Read is atomic
			return value == Guid.Empty;
		}
	}
}
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/sakno/DotNext/blob/gh-pages-2.x/docs/features/core/atomic.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
